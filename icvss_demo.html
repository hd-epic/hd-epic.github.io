<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <h1 style="text-align: center;"><img src="assets/img/hd-epic-logo-light.png" width="80"><br><a href='https://hd-epic.github.io'>HD-EPIC</a> ICVSS 2025 Demo</h1>
    <style>
        .wrapper {
            max-width: 1200px;
            margin: 0 auto;
        }

        body {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #f9f9f9;
            font-family: Arial, sans-serif;
            line-height: 1.0;
            color: #333;
            text-align: left;
        }
        video {
            border: 1px solid #ddd;
        }
        .controls {
            margin-top: 10px;
        }
        .progress-bar {
            width: 80%;
            max-width: 720px;
        }
        select {
            margin: 10px;
        }
        #videoFull {
            position: relative; /* Ensure video becomes a positioning reference */
            z-index: 1;        /* Keep video below the canvas */
        }

        #boundingBoxCanvas {
            position: absolute; /* Make canvas position absolutely */
            top: 0;            /* Align canvas with the top of the video */
            left: 0;           /* Align canvas with the left of the video */
            pointer-events: none; /* Allow video controls to work normally */
            z-index: 2;        /* Place canvas above the video */
        }

        div {
            position: relative; /* Make the parent div a positioning context */
            z-index: 1; 
        }

        .hidden {
            visibility: hidden;
        }

        #readme {
        max-width: 1000px; /* Keeps content readable */
        margin: 10px auto; /* Centers content with space around */
        padding: 10px;
        line-height: 1.4; /* Increases line spacing for better readability */
            }

        #readme p {
            margin-bottom: 16px; /* Adds spacing between paragraphs */
        }

        #readme ul {
            padding-left: 30px; /* Ensures proper indentation for list */
            margin-bottom: 16px; /* Adds spacing after list */
        }

        #readme li {
            margin-bottom: 8px; /* Adds spacing between list items */
        }
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 40px;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #000000;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .section {
            margin-bottom: 20px;
        }
        .highlight {
            font-weight: bold;
            color: #007BFF;
        }
        .button {
            display: block;
            width: 100px;
            margin: 20px auto;
            padding: 10px;
            text-align: center;
            background: #007BFF;
            color: #fff;
            text-decoration: none;
            border-radius: 5px;
        }
    </style>
</head>
<body class="wrapper">
    <div class="container">
        <p>This interface allows you to explore a sample of VQA questions. To access more, download the question file and HTML interface from <a href="https://github.com/hd-epic/hd-epic-annotations/blob/main/HD_EPIC_VQA_Interface.html">GitHub</a>.</p>
        
        <div class="section">
            <h2>How It Works:</h2>
            <ul>
                <li>The <span class="highlight">Video Player</span> shows full videos.</li>
                <li><span class="highlight">Timestamps</span> appear below the Video Player. Click to pause at that frame.</li>
                <li><span class="highlight">Bounding Boxes</span> are displayed if available.</li>
            </ul>
        </div>
        
        <div class="section">
            <p>Select an answer and click <span class="highlight">'Next'</span> to continue. Your accuracy will be tracked.</p>
        </div>
    </div>
            <div class="hidden">
        <label for="answer-file">Select Previous Saved Answer JSON File to <span style="color: red;">Continue (before select question json file)</span>, If Don't Have One, Leave It There:</label>
        <input type="file" id="answer-file" accept=".json" style="width: 100%;">
    </div>
    <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; height: 750px; text-align: center;">
        <div style="flex: 1 1 45%; text-align: center; position: relative; margin: 10px; max-width: 704px;">
            <h1>Video Player</h1>
            <div id="videoFull"></div>
            <canvas id="boundingBoxCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            <div>
                <select id="videoFullSelect">
                    </select>
            </div>
            <div class="choices-container" id="framesContainer">
                </div>
        </div>
    </div>
    
    <div id="question-section">
        <label for="question-keys">Select Question:</label>
        <select id="question-keys"></select>
        <p><strong>Question:</strong> <span id="question-text" style="line-height: 1.6;"></span></p>
    </div>

    <div class="choices-container" id="choicesContainer" style="line-height: 1.6;" >
    </div>

    <div style="display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 10px; width: 100%; height: 100px; margin: 0 auto;">
        <button class="button" id="nextButton">Next</button>
        <p id="accuracyLabel" style="margin: 0;">Accuracy: 0%, Correct: 0, Total: 0</p>
        <button id="saveButton" class="hidden"><span style="color: red;">Save</span></button>
    </div>

    <script src="http://www.youtube.com/iframe_api"></script>
    <script>
/***
 * get the required data
***/
        // set up
        const answerFile = document.getElementById('answer-file');
        // question display
        const questionSelect = document.getElementById('question-keys');
        const questionText = document.getElementById('question-text');
        const choicesContainer = document.getElementById("choicesContainer");
        // video
        const video_regex_1 = /<TIME (\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) video (\d+)> to <TIME (\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) video \d+>/g;
        const video_regex_2 = /<TIME (\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) video (\d+)> and <TIME (\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) video \d+>/;
        const videoFullSelect = document.getElementById("videoFullSelect");
        // image
        const image_regex =/<TIME (\d{1,2}:\d{1,2}:\d{1,2}\.\d{1,3}) video (\d+)>/;
        const framesContainer = document.getElementById('framesContainer'); // image (frame of a video)
        // next and accuracy
        const nextButton = document.getElementById("nextButton");
        const accuracyLabel = document.getElementById("accuracyLabel");
        const saveButton = document.getElementById("saveButton");
        //bbox
        const canvas = document.getElementById("boundingBoxCanvas");
        const context = canvas.getContext("2d");
        const bbox_regex = /<BBOX\s([\d\.]+)\s([\d\.]+)\s([\d\.]+)\s([\d\.]+)\s*\/?>/;

/***
 * global data
***/
        let saveFileName_1 = null;
        let saveFileName_2 = null;
        let answers = {}; //To store answers
        let fullVideos = []; //To store current full videos
        let frames = [];
        let bbox = []; //To store bounding box
        let correct = 0; //correct answer
        let total = 0; //total number of question you answer now
        let accuracy = 0;
        let videoFullPlayer;
        const video_src = {'P01-20240202-110250': 'YZo1sqXp5U0', 'P01-20240202-161354': 'iJpqrt4Uefc', 'P01-20240202-161948': 'I3ldXPd_d2g', 'P01-20240202-171220': 'Q_h1jmcIBAw', 'P01-20240202-175627': 'Epjp1Isub4Q', 'P01-20240202-195538': '1faxLHsp5ZI', 'P01-20240203-093333': 'Do_CbEBOFro', 'P01-20240203-121517': 'ozyqTW4FLFQ', 'P01-20240203-123350': 'x4STmay8sKI', 'P01-20240203-130505': 'HdDyqiLzT6g', 'P01-20240203-132119': 'PenWS6LTzDU', 'P01-20240203-135502': 'xR7ypKh8GUg', 'P01-20240203-150506': 'pgKE1TA8yKM', 'P01-20240203-152323': '_iElNa-jFDE', 'P01-20240203-152956': 'kRWcAuVKtqc', 'P01-20240203-161757': 'wC7ZmDtzrl4', 'P01-20240203-184045': '5nW8ksVP5yE', 'P01-20240203-184214': 'VFn2ir7RtAw', 'P01-20240204-095114': 'rSLV5Qx9l9s', 'P01-20240204-120411': 'ora_fTZr00A', 'P01-20240204-121042': '7JqcpAM4EXU', 'P01-20240204-124504': '1PDw8lZvUpY', 'P01-20240204-130448': '06EGRDGFB64', 'P01-20240204-142301': '09xxxPUCdUc', 'P01-20240204-145458': 'dVGiDRrddg4', 'P01-20240204-152537': '0wakJgxehI4', 'P01-20240204-160230': 'qtPElCGYMHo', 'P02-20240209-184316': 'ClT-r2qMfDQ', 'P02-20240209-194141': 'QLMFiW0bm1Q', 'P02-20240209-231412': 'UYaRHCakTsU', 'P02-20240210-092616': 'DExH8Rq-bsk', 'P02-20240210-100308': '8CgNOtu6rPA', 'P02-20240210-100930': 'aAbljb1FnWY', 'P02-20240210-113925': 'DuFatpo2zck', 'P02-20240210-122334': 'd6cer_Y681U', 'P02-20240210-195833': 'TS3XE9sALg8', 'P02-20240210-220650': 'EMGDuShuAaw', 'P02-20240211-100250': 'jlYpItmfW3k', 'P02-20240211-104948': 'RJK891ZzCIk', 'P02-20240211-111219': 'zWO833eWfag', 'P02-20240211-111822': 'UsXtkADcLW4', 'P02-20240211-115653': 'leeb_8o8mhk', 'P02-20240211-120927': 'bwDkI2vZ1Ow', 'P02-20240211-141313': '-nTu0lrK7lg', 'P02-20240211-175138': 'MfVeyV6KHxM', 'P02-20240211-182630': 'cP3Ze_zk4jo', 'P03-20240216-084005': '3VDExSVPRAM', 'P03-20240216-090759': 'xwD05cqaNI8', 'P03-20240216-185832': 'oF0kZUetsIc', 'P03-20240216-205923': 'ksIwSq7DgNk', 'P03-20240216-223126': 'MgEbPOsjl44', 'P03-20240217-091657': 'Wvm4Iti3HFg', 'P03-20240217-094713': 'uIFJOM3to-c', 'P03-20240217-100448': 'IGngQdnA7VM', 'P03-20240217-130208': 'OxlVOKg9L10', 'P03-20240217-131219': 'MtANW-VHeLc', 'P03-20240217-150310': 'NOsHm-8Kfe4', 'P03-20240217-152152': '9EVtt2kjg-Y', 'P03-20240217-192543': 'dPv24tndzU4', 'P03-20240217-210126': '_Oc6EP5-580', 'P03-20240217-210958': 'b6D-Jx7FSBI', 'P03-20240218-094452': 'raivW3uuNC8', 'P03-20240218-101509': 'MlPOnlO7RaM', 'P03-20240218-140054': 'MBRufovHQi8', 'P03-20240218-144430': 'I6tkXpYhVdY', 'P03-20240218-190556': 'lGKJgPs-Pjk', 'P03-20240218-202148': 'za_p9bd_Vkg', 'P04-20240413-142619': '5BkqfOu30Ec', 'P04-20240413-145245': 'eeCKS_CzKzc', 'P04-20240413-151722': 'AS5nT9yMtbo', 'P04-20240414-064514': 'bk35JWOogGg', 'P04-20240414-065311': 'JwoPd_13Lko', 'P04-20240414-072251': 'Xvikr2gIsC4', 'P04-20240414-162242': 'kZTn1gaSf_0', 'P04-20240414-162750': 'hFzaq4tOR0Q', 'P04-20240414-164751': 'uZF5dt4hptU', 'P04-20240414-165333': 'yJBUr83vtX0', 'P04-20240414-170520': 'S7CG5gIxS5s', 'P04-20240414-172534': 'LWMOGzdnZGQ', 'P04-20240414-173337': '0mviwgLRV5o', 'P04-20240414-175337': '8PS08A42K9Q', 'P04-20240414-181030': '3MjTHAjHO4E', 'P04-20240415-175615': '8otKXM5Kj-k', 'P04-20240415-181212': 'q2FOi2zBRGI', 'P04-20240415-184003': '_3uENcOu0Wg', 'P05-20240423-170021': '-bfqvpDPins', 'P05-20240423-172243': 'm7dB1IQPF3s', 'P05-20240423-175745': 'XkMuNjbOipg', 'P05-20240423-180529': 'zGcwmFLaS1E', 'P05-20240423-183358': '-ZVsnskCGbI', 'P05-20240424-085204': 'pcwo46NyzzY', 'P05-20240424-090812': 'zcsyxpzE-yY', 'P05-20240424-130119': 'nOkttredqtQ', 'P05-20240424-131231': '2XYaMEcHKpE', 'P05-20240424-171038': '0LTgW-QWuiY', 'P05-20240424-175101': 'Au5WmQ9wQis', 'P05-20240425-082420': '89k2h5npErg', 'P05-20240425-083515': 'V_SnJ2-AcP0', 'P05-20240425-124420': '0NPJp542W2I', 'P05-20240425-125459': 'tNThxcw9T9w', 'P05-20240425-171455': 'eMeXg-8DVvQ', 'P05-20240425-173353': 'XUpcsJO03YE', 'P05-20240425-180658': 'EC8u03v6iQM', 'P05-20240425-201444': 'OkF3oJZmVZ8', 'P05-20240426-085333': 'YbJ_AKPGnJM', 'P05-20240426-091011': 'fmCmCWxgw28', 'P05-20240426-092000': 'r2WbnQj3Klg', 'P05-20240427-143353': 'ne67bnDFy0E', 'P05-20240427-145526': '2yMGlZU2r0E', 'P05-20240427-150402': 'K5BHJ6f0rXU', 'P05-20240427-151808': 'nKtVMp7TW2g', 'P06-20240510-090328': 'fySE6P-hiOg', 'P06-20240510-094438': '3GWSDWfUoQ0', 'P06-20240510-100047': '1MthVWI-HDc', 'P06-20240510-104642': 'gmvnmxz0fvg', 'P06-20240510-115307': 'YrwLEsYui6M', 'P06-20240510-121619': 'MvGcZj_3VvI', 'P06-20240510-135423': 'Rs8SozeRBSU', 'P06-20240510-140459': 'xVpNL5CQtHg', 'P06-20240511-102207': 'CfD8JwSTawk', 'P06-20240511-121048': 'dRhC716vd68', 'P06-20240511-122221': 'XHjyMr158_I', 'P07-20240529-102652': 'iCfzOA1RaLU', 'P07-20240529-131737': '8-xn8-xsllQ', 'P07-20240529-134410': 'Rnmf09yzNAE', 'P07-20240529-191007': 'ye9LXg30G7w', 'P07-20240529-194518': '5X7RFVul2uo', 'P07-20240530-102543': 'a6wcjtATIeU', 'P07-20240530-111344': 'KMBj0Sq7vZg', 'P07-20240531-101357': 'zInGsEULHX8', 'P07-20240531-201703': '1qeKWyfu3qQ', 'P08-20240613-122900': '50cGIL39mDk', 'P08-20240613-123547': 'F4MzdUd6ClM', 'P08-20240614-085000': 'SzNR3vEJAYE', 'P08-20240614-125650': 'lDstsmGmrlM', 'P08-20240614-132938': 'pI1xR81gZz0', 'P08-20240614-184945': 'e397Y4grt1k', 'P08-20240617-130401': 'OstYPS-rZ9g', 'P08-20240617-184909': '_OfP5Ypq4XQ', 'P08-20240618-163547': 'Vf1pbMbVkYA', 'P08-20240618-171546': '_EA6wUp1S-M', 'P08-20240620-180825': 'k6_z-Lvxytk', 'P08-20240622-141902': 'sE68I_7B1sw', 'P09-20240621-093545': 'UpLFLWsfzaM', 'P09-20240621-153208': 'esvILIGB-_g', 'P09-20240622-150155': 'it6f1pYx9s4', 'P09-20240622-154652': 'BnlhxK1FUY8', 'P09-20240622-162302': 'sEXzejsaR88', 'P09-20240622-194642': 'DiZu60NkEYk', 'P09-20240623-120359': '8PA9Kdaujm4', 'P09-20240623-153253': 'pDG6tW3tA0o', 'P09-20240623-153748': 'Rj1oxJgsxYs', 'P09-20240623-154547': 'CkvdwVh60Pk', 'P09-20240624-160737': 'ooIy3_vTXKw', 'P09-20240624-165332': 'OhTeD0DY6q4', 'P09-20240625-103827': 'GOktVMb9pzY'};
        const questions = {
  "question_1": {
    "inputs": {
      "video 1": {
        "id": "P04-20240414-072251"
      }
    },
    "question": "Where was the object <BBOX 892.93675 618.55726 1051.78816 779.815> seen at <TIME 00:08:17.5 video 1> moved from/to throughout the video?",
    "choices": [
      "from counter right of hob to cupboard top left of windowsill",
      "from counter left of sink to sink, then from sink to counter left of sink, then from counter left of sink to cupboard top right of hob",
      "from sink to cupboard top left of windowsill, then from cupboard top left of windowsill to counter right of hob, then from counter right of hob to counter top right of dishwasher, then from counter top right of dishwasher to counter top right of fridge",
      "from sink to counter left of sink, then from counter left of sink to sink, then from sink to counter left of sink",
      "from counter left of sink to sink, then from sink to counter right of hob, then from counter right of hob to drawer bottom right of hob"
    ],
    "correct_idx": 1
  },
  "question_5": {
    "inputs": {
      "video 1": {
        "id": "P09-20240621-093545"
      }
    },
    "question": "Given the direction I am looking at <TIME 00:29:40.167 video 1>, where is the bin located?",
    "choices": [
      "3 o'clock",
      "11 o'clock",
      "1 o'clock",
      "4 o'clock",
      "8 o'clock"
    ],
    "correct_idx": 4
  },
  "question_6": {
    "inputs": {
      "video 1": {
        "id": "P08-20240614-085000"
      }
    },
    "question": "Where was the object <BBOX 999.763 985.878 1188.607 1102.517> seen at <TIME 00:07:48.467 video 1> moved from/to throughout the video?",
    "choices": [
      "from fridge to counter right of sink, then from counter right of sink to fridge",
      "from counter top right of dishwasher to counter right of sink, then from counter right of sink to counter top right of dishwasher",
      "from drawer bottom left of hob to counter left of hob, then from counter left of hob to counter top right of dishwasher, then from counter top right of dishwasher to counter right of hob, then from counter right of hob to counter top right of dishwasher",
      "from counter right of hob to sink, then from sink to counter top right of dishwasher",
      "from oven to counter right of sink, then from counter right of sink to counter right of hob, then from counter right of hob to counter top right of dishwasher, then from counter top right of dishwasher to hook"
    ],
    "correct_idx": 3
  },
  "question_7": {
    "inputs": {
      "video 1": {
        "id": "P03-20240217-094713"
      }
    },
    "question": "Which of these objects did the person take from the item indicated by bounding box <BBOX 516.6089496949786 535.9920260632691 1078.2732526219788 1281.312912450507> in <TIME 00:02:31.1 video 1>?",
    "choices": [
      "knife",
      "Nothing",
      "butter, bread piece, jam jar",
      "tea towel, phone, box",
      "knife, glass"
    ],
    "correct_idx": 2
  },
  "question_9": {
    "inputs": {
      "video 1": {
        "id": "P01-20240202-161354"
      }
    },
    "question": "Which of these objects did the person take from the item indicated by bounding box <BBOX 77.94733960845588 599.2912337559792 942.0838899439254 1012.0226878328651> in <TIME 00:03:29.667 video 1>?",
    "choices": [
      "large white jug of dishwashing liquid",
      "jar of black pepper, salt bottle",
      "spoon",
      "plastic box lid, napkin",
      "bowl, cloth"
    ],
    "correct_idx": 1
  },
  "question_10": {
    "inputs": {
      "video 1": {
        "id": "P09-20240621-093545"
      }
    },
    "question": "Given the direction I am looking at <TIME 00:32:36.6 video 1>, where is the microwave located?",
    "choices": [
      "1 o'clock",
      "7 o'clock",
      "10 o'clock",
      "11 o'clock",
      "12 o'clock"
    ],
    "correct_idx": 1
  },
  "question_11": {
    "inputs": {
      "video 1": {
        "id": "P06-20240510-094438"
      }
    },
    "question": "How many times did I close the item indicated by bounding box <BBOX 233.7599860612545 614.0882853639492 912.1049595181222 1127.7328457352771> in <TIME 00:02:21.167 video 1>?",
    "choices": [
      "4",
      "3",
      "1",
      "0",
      "2"
    ],
    "correct_idx": 2
  },
  "question_15": {
    "inputs": {
      "video 1": {
        "id": "P02-20240211-115653"
      }
    },
    "question": "Given the direction I am looking at <TIME 00:10:16.9 video 1>, where is the microwave located?",
    "choices": [
      "12 o'clock",
      "7 o'clock",
      "1 o'clock",
      "10 o'clock",
      "3 o'clock"
    ],
    "correct_idx": 4
  },
  "question_20": {
    "inputs": {
      "video 1": {
        "id": "P01-20240203-152323"
      }
    },
    "question": "How many times did I close the item indicated by bounding box <BBOX 594.4692639100286 597.3944754080604 907.4348239338321 841.2537315073224> in <TIME 00:00:29.333 video 1>?",
    "choices": [
      "3",
      "2",
      "4",
      "1",
      "0"
    ],
    "correct_idx": 0
  },
  "question_22": {
    "inputs": {
      "video 1": {
        "id": "P06-20240510-090328"
      }
    },
    "question": "Given the direction I am looking at <TIME 00:12:21.367 video 1>, where is the top of fridge located?",
    "choices": [
      "7 o'clock",
      "1 o'clock",
      "8 o'clock",
      "3 o'clock",
      "11 o'clock"
    ],
    "correct_idx": 3
  },
  "question_23": {
    "inputs": {
      "video 1": {
        "id": "P03-20240217-210126"
      }
    },
    "question": "Where was the object <BBOX 813.51111 387.501 984.3965800000001 611.3367499999999> seen at <TIME 00:01:36.633 video 1> moved from/to throughout the video?",
    "choices": [
      "from counter top left of dishwasher to dishwasher, then from dishwasher to table right of radiator, then from table right of radiator to dishwasher",
      "from dishwasher to sink",
      "from table right of radiator to sink",
      "from sink to dishwasher, then from dishwasher to counter top left of dishwasher, then from counter top left of dishwasher to dishwasher",
      "from table right of radiator to counter top left of dishwasher, then from counter top left of dishwasher to dishwasher"
    ],
    "correct_idx": 4
  },
  "question_24": {
    "inputs": {
      "video 1": {
        "id": "P08-20240614-184945"
      }
    },
    "question": "Given the direction I am looking at <TIME 00:00:9.667 video 1>, where is the oven located?",
    "choices": [
      "11 o'clock",
      "10 o'clock",
      "4 o'clock",
      "12 o'clock",
      "6 o'clock"
    ],
    "correct_idx": 2
  }
};
/***
 * set up
***/
        function onYouTubeIframeAPIReady() {
            setupQuizApp(questions);
        }
/***
 * question display
***/
        // Setup Quiz App
        function setupQuizApp(questions) {
            const questionKeys = Object.keys(questions);
            // Sort question keys numerically
            questionKeys.sort((a, b) => {
                const numA = parseInt(a.split('_')[1]);
                const numB = parseInt(b.split('_')[1]);
                return numA - numB;
            });

            const currentQuestionKey = questionKeys[Object.keys(answers).length];
            saveFileName_1 = `${currentQuestionKey}_answer.json`;
            saveFileName_2 = `${currentQuestionKey}_accuracy.text`;
            correct = 0; //correct answer
            total = 0; //total number of question you answer now
            for (const key in answers) {
                if (answers.hasOwnProperty(key)) {
                    correct += answers[key]['correct'];
                    total += 1;
                }
            }
            if (total !== 0){
                accuracy = correct/total
                accuracyLabel.textContent = `Accuracy: ${(accuracy * 100).toFixed(2)}%, Correct: ${correct}, Total: ${total}`;
            }
            // Populate question dropdown
            questionSelect.innerHTML = '';
            questionKeys.forEach((key, index) => {
                const option = document.createElement('option');
                option.value = key;
                // Display "Question 1", "Question 2", etc.
                option.textContent = `Question ${index + 1}`; 
                questionSelect.appendChild(option);
            });
            // Set default question
            questionSelect.value = currentQuestionKey;
            displayQuestion(currentQuestionKey);
        }
        // Question Change Event
        questionSelect.addEventListener('change', function() {
            const currentQuestionKey = this.value;
            displayQuestion(currentQuestionKey);
        });
        // next button and change accuracy
        nextButton.addEventListener("click", () => {
            // calucalte result, record and update
            const selectedIndex = getSelectedIndex();
            if (selectedIndex === -1) {
                alert("Please select an answer!");
            } else {
                const currentIndex = questionSelect.selectedIndex;
                const questionKeys = Object.keys(questions).sort((a, b) => {
                    const numA = parseInt(a.split('_')[1]);
                    const numB = parseInt(b.split('_')[1]);
                    return numA - numB;
                });
                const currentQuestionKey = questionKeys[currentIndex];
                const currentQuestion = questions[currentQuestionKey]
                if (selectedIndex == currentQuestion['correct_idx']){
                    correct += 1;
                    total += 1;
                    answers[currentQuestionKey] = {correct_idx:currentQuestion['correct_idx'], choice:selectedIndex, correct:1};
                } else{
                    total += 1;
                    answers[currentQuestionKey] = {correct_idx:currentQuestion['correct_idx'], choice:selectedIndex, correct:0};
                }
                accuracy = correct/total
                accuracyLabel.textContent = `Accuracy: ${(accuracy * 100).toFixed(2)}%, Correct: ${correct}, Total: ${total}`;
                // change to next one
                const nextIndex = currentIndex + 1;
                const nextQuestionKey = questionKeys[nextIndex]; // Use sorted keys
                if (nextIndex < questionSelect.options.length) {
                    questionSelect.value = nextQuestionKey;
                    displayQuestion(nextQuestionKey);
                } else {
                    handleCompletion();
                }
            }
        });

        function reset() {
            // remove data from last question
            choicesContainer.innerHTML = ''; // Clear existing choices
            videoFullSelect.innerHTML = ''; // Clear any existing options
            framesContainer.innerHTML = ''; // Clear any existing options
            if (videoFullPlayer) {
                videoFullPlayer.destroy(); // Properly destroy the existing player
                videoFullPlayer = null;   // Reset the variable to null
            }
            fullVideos = [];
            frames = [];
            bbox = [];
            clearBoundingBox();
        }

        // Display Question and Related Data
        function displayQuestion(questionKey) {
            reset()
            // the choices and the quesiton
            const questionData = questions[questionKey];
            questionText.textContent = questionData['question'];
            populateChoices(questionData['choices'])
            for (const key in questionData['inputs']) {
                item = questionData['inputs'][key]
                path = video_src[item['id']];
                if ('time' in item) {
                    if (!(questionKey.includes("object_motion_object_movement_counting") || questionKey.includes("object_motion_stationary_object_localization"))){
                        frames.push({name: key, src: path, time: timeToSeconds(item['time'])})
                        fullVideos.push({name: key, src: path})
                    }
                } else {
                    fullVideos.push({name: key, src: path})
                }
            }
            
            // add frames from questions
            if (!questionKey.includes("nutrition_nutrition_change")){
                f_match = image_regex.exec(questionData['question'])
                if (f_match !== null){
                    const time = f_match[1];    // Extracted time: "00:13:21.3"
                    const videoNumber = f_match[2];    // Extracted video number: "1"
                    const video = `video ${videoNumber}`;
                    item = questionData['inputs'][video]
                    if (item.id in video_src) {
                            path = video_src[item['id']];
                        } else {
                            // This path construction assumes 'folderPath' is defined elsewhere or not needed.
                            // If 'folderPath' is needed, ensure it's defined globally or passed.
                            // For now, it's commented out as it wasn't defined in the provided snippet.
                            // subfolder = item['id'].split('-')[0];    // This will give you "P03"
                            // path = `${folderPath.replace(/\\/g, '/')}/${subfolder}/${item['id']}.mp4`;
                            path = video_src[item['id']]; // Fallback to direct video_src if folderPath logic isn't complete
                        }
                    frames.push({name: `${video}`, src: path, time: timeToSeconds(time)})
                    // Check if none of the videos has the name equal to 'somevalue'
                    if (!fullVideos.some(video => video.src === path)) {
                        fullVideos.push({name: `${video}`, src: path})
                    }
                    bbox_match = bbox_regex.exec(questionData['question'])
                    if (bbox_match !== null) {
                        // Parse the values to floats, y1, x1, y2, x2
                        const y = parseFloat(bbox_match[1]);
                        const x = parseFloat(bbox_match[2]);
                        const height = parseFloat(bbox_match[3]) - y;
                        const width = parseFloat(bbox_match[4]) - x;
                        bbox.push({x:x, y:y, width:width, height:height, time:timeToSeconds(time), src:path})
                    }
                }
            }
            // put list to the full videos
            populateVideoOptions(fullVideos); // Populate the dropdown
            
        }
    
        // Function to populate the choices dynamically
        function populateChoices(choices) {
            choicesContainer.innerHTML = ''; // Clear existing choices
            choices.forEach((choice, index) => {
                const choiceItem = document.createElement("div");
                choiceItem.classList.add("choice-item");

                const radioButton = document.createElement("input");
                radioButton.type = "radio";
                radioButton.name = "choices"; // All radio buttons belong to the same group
                radioButton.id = `choice-${index}`;  // Set ID as the index
                radioButton.value = choice;  // Set value as the choice text

                const label = document.createElement("label");
                label.setAttribute("for", `choice-${index}`);
                label.textContent = choice;

                // Append the radio button and label to the choice item
                choiceItem.appendChild(radioButton);
                choiceItem.appendChild(label);

                // Append the choice item to the container
                choicesContainer.appendChild(choiceItem);
            });
        }

        // Function to get the selected radio button index
        function getSelectedIndex() {
            const selectedRadio = document.querySelector('input[name="choices"]:checked'); // Get the checked radio button
            if (selectedRadio) {
                const selectedIndex = Array.from(document.querySelectorAll('input[name="choices"]')).indexOf(selectedRadio);
                return selectedIndex; // Return the index of the selected radio button
            }
            return -1; // Return -1 if no radio button is selected
        }

        //change time format
        function timeToSeconds(timeString) {
            const parts = timeString.split(":");
            
            if (parts.length === 3) {
                // Format: HH:MM:SS.MS
                const [hours, minutes, secondsWithMilliseconds] = parts;
                const [seconds, milliseconds] = secondsWithMilliseconds.split(".");
                const totalSeconds = (Number(hours.padStart(2, '0')) * 3600) + (Number(minutes.padStart(2, '0')) * 60) + Number(seconds.padStart(2, '0')) + (milliseconds ? Number(milliseconds.padEnd(3, '0')) / 1000 : 0);
                return totalSeconds;
            } else if (parts.length === 2) {
                // Format: MM:SS.MS
                const [minutes, secondsWithMilliseconds] = parts;
                const [seconds, milliseconds] = secondsWithMilliseconds.split(".");
                const totalSeconds = (Number(minutes.padStart(2, '0')) * 60) + Number(seconds.padStart(2, '0')) + (milliseconds ? Number(milliseconds.padEnd(3, '0')) / 1000 : 0);
                return totalSeconds;
            } else {
                throw new Error("Invalid time format. Expected HH:MM:SS.MS or MM:SS.MS.");
            }
        }

/***
 * Full Videos
***/
        // Function to load video options dynamically
        function populateVideoOptions(videos) {
            videoFullSelect.innerHTML = ''; // Clear existing options before populating
            videos.forEach((video, index) => {
                const opt = document.createElement("option");
                opt.value = index; // Set the video source as the value
                opt.textContent = video['name']; // Set a display name
                videoFullSelect.appendChild(opt);
            });

            // Automatically select and load the first video
            if (videos.length > 0) {
                loadFullVideo(fullVideos[0], videoFullSelect.options[videoFullSelect.selectedIndex].text);
            }
        }

        // Function to load and play the selected video
        function loadFullVideo(video, video_name) {
            if (video) {
                // Destroy existing player if it exists
                if (videoFullPlayer) {
                    videoFullPlayer.destroy();
                }

                videoFullPlayer = new YT.Player('videoFull', {
                    width:550,
                    height: 500,
                    videoId: video.src,
                    events:{
                        'onReady': function (event) {
                            onPlayerReady_Full(event, video_name); // Pass video_name here
                        },
                        'onStateChange': onPlayerStateChange_Full
                    },
                    playerVars: {
                        'controls': 1, // Show controls
                        'autoplay': 1,  // Autoplay video
                        'modestbranding': 1, // Hide YouTube logo
                        'rel': 0,  // Do not show related videos at the end
                        'showinfo': 0 // Hide video info
                    }
                });
            }
        }

        function onPlayerReady_Full(event, video_name) {
            event.target.playVideo();
            if (frames.length > 0){
                const filteredTimes = frames.filter(item => item.name === video_name).map(item => item.time);
                populateFrames(filteredTimes, video_name); // Start capturing frames once the video is ready
            }
        }

        // Function to handle state changes
        function onPlayerStateChange_Full(event) {
            if (event.data === YT.PlayerState.PLAYING) {
                // Call uncheckRadios when the video starts playing
                uncheckRadios();
            }
        }

        // Add an event listener for when a new video is selected
        videoFullSelect.addEventListener("change", function () {
            const selectedVideo = fullVideos[this.value]; // Get the selected value
            if (videoFullPlayer) {
                videoFullPlayer.destroy(); // Properly destroy the existing player
                videoFullPlayer = null;   // Reset the variable to null
            }
            loadFullVideo(selectedVideo, videoFullSelect.options[this.value].text);
        });
/**
 * image
**/
        function populateFrames(times, video_name) {
            framesContainer.innerHTML = ''; // Clear any existing options

            times.forEach((time, index) => {
                const radioButton = document.createElement("input");
                radioButton.type = "radio";
                radioButton.name = "frames"; // All radio buttons belong to the same group
                radioButton.id = `frame-${index}`;  // Set ID as the index
                radioButton.value = time;  // Set value as the time for this frame

                const label = document.createElement("label");
                label.setAttribute("for", `frame-${index}`);
                const show_time = secondsToTimeFormat(time);
                label.textContent = `${show_time} of ${video_name}`;

                // Append the radio button and label to the choice item
                framesContainer.appendChild(radioButton);
                framesContainer.appendChild(label);

                // Add event listener for radio button click
                radioButton.addEventListener("click", function() {
                        videoFullPlayer.seekTo(time, true);
                        videoFullPlayer.pauseVideo();
                        adjustCanvasSize();
                    });
            });

        }

        function uncheckRadios() {
            // Get all radio buttons inside frameItem
            const radioButtons = framesContainer.querySelectorAll("input[type='radio']");
            
            // Iterate through all radio buttons and set checked to false
            radioButtons.forEach(radio => {
                radio.checked = false;
            });
            clearBoundingBox();
        }

        function secondsToTimeFormat(seconds) {
            // Get the integer part of seconds (for hours, minutes, and seconds)
            const totalSeconds = Math.floor(seconds);
            const milliseconds = Math.round((seconds - totalSeconds) * 1000);

            // Calculate hours, minutes, and seconds
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const remainingSeconds = totalSeconds % 60;

            // Format the time as HH:MM:SS.MS
            const formattedTime = `${padZero(hours)}:${padZero(minutes)}:${padZero(remainingSeconds)}.${padZero(milliseconds, 3)}`;

            return formattedTime;
        }
        // Helper function to add leading zeros
        function padZero(num, length = 2) {
            return num.toString().padStart(length, '0');
        }

/**
 * bounding box
**/
        // Draw a bounding box
        function drawBoundingBox() {
            context.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            context.strokeStyle = 'red'; // Bounding box color
            context.lineWidth = 2;       // Bounding box thickness
            // Scale factors based on the assumption that the original video resolution
            // for bounding boxes is 1920x1080 (or similar, adjusted for 1408 if it's a fixed ratio)
            // and the player's height is 500.
            // If the video resolution in the JSON is 1920x1080, and the player height is 500,
            // then a scaling factor from 1080 to 500 would be 500/1080.
            // The canvas width and height are set to 550x500. So we need to consider how the
            // original bounding box coordinates (likely from a 1920x1080 frame) map to the 550x500 player.
            // Assuming the video is letterboxed/pillarboxed to fit the 550x500 frame,
            // we need to maintain the aspect ratio of the *original* video for accurate bounding box placement.
            // EPIC-Kitchens videos are typically 1920x1080.
            const originalVideoWidth = 1920; 
            const originalVideoHeight = 1080; 
            
            const playerWidth = 550;
            const playerHeight = 500;

            let scale = Math.min(playerWidth / originalVideoWidth, playerHeight / originalVideoHeight);
            let scaledWidth = originalVideoWidth * scale;
            let scaledHeight = originalVideoHeight * scale;

            let offsetX = (playerWidth - scaledWidth) / 2;
            let offsetY = (playerHeight - scaledHeight) / 2;

            context.strokeRect(
                bbox[0].x * scale + offsetX, 
                bbox[0].y * scale + offsetY, 
                bbox[0].width * scale, 
                bbox[0].height * scale
            );
        }    
        // Hide the bounding box
        function clearBoundingBox() {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }
        // Set canvas size based on the video size while maintaining aspect ratio
        function adjustCanvasSize() {
            const videoFullElement = document.getElementById('videoFull');
            // The YouTube iframe itself is what we need dimensions from.
            // The videoFull div is just its container.
            // Assuming the iframe is created and available in the DOM when this is called.
            const iframe = videoFullElement.querySelector('iframe');
            if (iframe) {
                canvas.width = iframe.offsetWidth;
                canvas.height = iframe.offsetHeight;

                // Position the canvas exactly over the iframe
                canvas.style.position = 'absolute';
                canvas.style.top = iframe.offsetTop + 'px';
                canvas.style.left = iframe.offsetLeft + 'px';
            } else {
                // Fallback if iframe isn't immediately available (e.g., player still loading)
                // Use the container dimensions, though this might be less precise.
                canvas.width = videoFullElement.offsetWidth;
                canvas.height = videoFullElement.offsetHeight;
                canvas.style.position = 'absolute';
                canvas.style.top = videoFullElement.offsetTop + 'px';
                canvas.style.left = videoFullElement.offsetLeft + 'px';
            }


            // If you want the video to play after resizing
            if (bbox.length > 0) {
                drawBoundingBox();
            }
        }

        // Adjust canvas size when the window is resized to maintain aspect ratio
        window.addEventListener('resize', adjustCanvasSize);
        
/**
 * download
**/
        function downloadAnswer() {
            // No download functionality in this simplified version
        }

        function handleCompletion(){
            const finalAccuracy = total === 0 ? 0 : (correct / total * 100).toFixed(2);
            alert(`Quiz Completed!\nYour total score: ${correct} out of ${total}\nAccuracy: ${finalAccuracy}%`);
            // You can also disable the next button or hide the question section
            nextButton.disabled = true;
            // Optionally hide the question and choices
            document.getElementById('question-section').style.display = 'none';
            choicesContainer.style.display = 'none';
        }
        saveButton.addEventListener('click', downloadAnswer); 
    </script>
</body>
</html>